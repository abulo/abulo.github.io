{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Abulo Hoo","url":"http://abulo.github.io"},"pages":[{"title":"关于","date":"2019-01-06T09:27:10.000Z","updated":"2019-01-06T09:55:05.496Z","comments":false,"path":"about/index.html","permalink":"http://abulo.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;abulo&apos; age: 32, gender: &apos;男&apos;, profession: &apos;Developer&apos;, experience: &apos;10年+&apos;, address: &apos;四川省成都市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/abulo&apos;, blog: &apos;http://abulo.github.io&apos;, email: &apos;abulo.hoo@gmail.com&apos;, description: &apos;致力于Web后端开发交互&apos;, skills: [ [&apos;PHP&apos;, &apos;Swoole&apos;,&apos;Python&apos;,&apos;Golang&apos;], [&apos;Git&apos;, &apos;SVN&apos;], [&apos;MySQL&apos;,&apos;Redis&apos;] ], devTools: [ [&apos;Sublime Text&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;, &apos;Fiddler&apos;], [&apos;SourceTree&apos;, &apos;TortoiseSVN&apos;], [&apos;SwitchHosts&apos;], [&apos;Navicat&apos;, &apos;XAMPP&apos;], ]&#125;"},{"title":"书单","date":"2019-01-06T09:54:59.325Z","updated":"2019-01-06T09:54:59.325Z","comments":false,"path":"books/index.html","permalink":"http://abulo.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-01-06T09:54:52.610Z","updated":"2019-01-06T09:54:52.610Z","comments":false,"path":"categories/index.html","permalink":"http://abulo.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-01-06T09:54:39.257Z","updated":"2019-01-06T09:54:39.257Z","comments":false,"path":"repository/index.html","permalink":"http://abulo.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-06T09:54:31.302Z","updated":"2019-01-06T09:54:31.302Z","comments":false,"path":"tags/index.html","permalink":"http://abulo.github.io/tags/index.html","excerpt":"","text":""},{"title":"Link","date":"2019-01-06T09:44:17.914Z","updated":"2019-01-06T09:44:17.914Z","comments":true,"path":"links/index.html","permalink":"http://abulo.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis.conf 中文版","slug":"Redis-conf-中文版","date":"2009-05-14T05:41:00.000Z","updated":"2019-01-06T09:03:04.203Z","comments":true,"path":"2009/05/14/Redis-conf-中文版/","link":"","permalink":"http://abulo.github.io/2009/05/14/Redis-conf-中文版/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376# Redis示例配置文件# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## 单位是大小写不敏感的，所以1GB 1Gb 1gB的写法都是完全一样的。# Redis默认是不作为守护进程来运行的。你可以把这个设置为&quot;yes&quot;让它作为守护进程来运行。# 注意，当作为守护进程的时候，Redis会把进程ID写到 /var/run/redis.piddaemonize no# 当以守护进程方式运行的时候，Redis会把进程ID默认写到 /var/run/redis.pid。你可以在这里修改路径。pidfile /var/run/redis.pid# 接受连接的特定端口，默认是6379。# 如果端口设置为0，Redis就不会监听TCP套接字。port 6379# 如果你想的话，你可以绑定单一接口；如果这里没单独设置，那么所有接口的连接都会被监听。## bind 127.0.0.1# 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果你不指定的话，Redis就不会通过unix套接字来监听。## unixsocket /tmp/redis.sock# unixsocketperm 755#一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)timeout 0# 设置服务器调试等级。# 可能值：# debug （很多信息，对开发/测试有用）# verbose （很多精简的有用信息，但是不像debug等级那么多）# notice （适量的信息，基本上是你生产环境中需要的程度）# warning （只有很重要/严重的信息会记录下来）loglevel verbose# 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。# 注意：如果Redis以守护进程方式运行，而你设置日志显示到标准输出的话，那么日志会发送到 /dev/nulllogfile stdout# 要使用系统日志记录器很简单，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。# 然后根据需要设置其他一些syslog参数就可以了。# syslog-enabled no# 指明syslog身份# syslog-ident redis# 指明syslog的设备。必须是一个用户或者是 LOCAL0 ~ LOCAL7 之一。# syslog-facility local0# 设置数据库个数。默认数据库是 DB 0，你可以通过SELECT &lt;dbid&gt; WHERE dbid（0～&apos;databases&apos; - 1）来为每个连接使用不同的数据库。databases 16################################ 快照 ################################### 把数据库存到磁盘上:## save &lt;seconds&gt; &lt;changes&gt;## 会在指定秒数和数据变化次数之后把数据库写到磁盘上。## 下面的例子将会进行把数据写入磁盘的操作:# 900秒（15分钟）之后，且至少1次变更# 300秒（5分钟）之后，且至少10次变更# 60秒之后，且至少10000次变更## 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。save 900 1save 300 10save 60 10000# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象。# 默认设置为 &quot;yes&quot;，所以几乎总是生效的。# 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key的话，那数据文件就会更大了。rdbcompression yes# 数据库的文件名dbfilename dump.rdb# 工作目录## 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。## 累加文件也放这里。## 注意你这里指定的必须是目录，不是文件名。dir ./################################# 同步 ################################### 主从同步。通过 slaveof 配置来实现Redis实例的备份。# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。## slaveof &lt;masterip&gt; &lt;masterport&gt;# 如果master设置了密码（通过下面的 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。## masterauth &lt;master-password&gt;# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：## 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。# 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步（SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。#slave-serve-stale-data yes# slave根据指定的时间间隔向服务器发送ping请求。# 时间间隔可以通过 repl_ping_slave_period 来设置。# 默认10秒。## repl-ping-slave-period 10# 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。# 默认值60秒。## 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。## repl-timeout 60################################## 安全 #################################### 要求客户端在处理任何命令时都要验证身份和密码。# 这在你信不过来访者时很有用。## 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证（例如：它们运行在自己的服务器上。）## 警告：因为Redis太快了，所以居心不良的人可以每秒尝试150k的密码来试图破解密码。# 这意味着你需要一个高强度的密码，否则破解太容易了。## requirepass foobared# 命令重命名## 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法做坏事了。## 例如:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令：## rename-command CONFIG &quot;&quot;################################### 限制 ###################################### 设置最多同时连接客户端数量。# 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。# 特殊值&quot;0&quot;表示没有限制。# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&quot;达到最大用户数上限（max number of clients reached）&quot;## maxclients 128# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。## 如果因为删除策略问题Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更多内存的错误信息给命令。# 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。## 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）的时候，这个选项还是满有用的。## 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。# 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。## 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。# （如果策略设置为&quot;noeviction&quot;的话就不无所谓了）## maxmemory &lt;bytes&gt;# 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选：## volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。# allkeys-lru -&gt; 根据LRU算法删除任何key。# volatile-random -&gt; 根据过期设置来随机删除key。# allkeys-&gt;random -&gt; 无差别随机删。# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）# noeviction -&gt; 谁也不删，直接在写操作时返回错误。## 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。## 这里涉及的命令：set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## 默认值如下：## maxmemory-policy volatile-lru# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样例做测试。# 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。## maxmemory-samples 3############################## 纯累加模式 ################################ 默认情况下，Redis是异步的把数据导出到磁盘上。这种情况下，当Redis挂掉的时候，最新的数据就丢了。# 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。# 每次启动时Redis都会把这个文件的数据读入内存里。## 注意，异步导出的数据库文件和纯累加文件可以并存（你得把上面所有&quot;save&quot;设置都注释掉，关掉导出机制）。# 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。## 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。appendonly no# 纯累加文件名字（默认：&quot;appendonly.aof&quot;）# appendfilename appendonly.aof# fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。# 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。## Redis支持三种不同的模式：## no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。# always：每次写操作都立刻写入到aof文件。慢，但是最安全。# everysec：每秒写一次。折衷方案。## 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。# 如果你真的理解了这个意味着什么，那么设置&quot;no&quot;可以获得更好的性能表现（如果丢数据的话，则只能拿到一个不是很新的快照）；# 或者相反的，你选择 &quot;always&quot; 来牺牲速度确保数据安全、完整。## 如果拿不准，就用 &quot;everysec&quot;# appendfsync alwaysappendfsync everysec# appendfsync no# 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，那么后台的存储进程（后台存储或写入AOF日志）会产生很多磁盘I/O开销。# 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。## 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。## 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）## 如果你有延迟的问题那就把这个设为 &quot;yes&quot;，否则就保持 &quot;no&quot;，这是保存持久数据的最安全的方式。no-appendfsync-on-rewrite no# 自动重写AOF文件## 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。## 工作原理：Redis记住上次重写时AOF日志的大小（或者重启后没有写操作的话，那就直接用此时的AOF文件），# 基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。## 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。## 指定百分比为0会禁用AOF自动重写特性。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################## 慢查询日志 #################################### Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。# 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间（这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景）## 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。## 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。slowlog-log-slower-than 10000# 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。（译者注：日志居然是在内存里的Orz）slowlog-max-len 128################################ 虚拟内存 ################################## 警告！虚拟内存在Redis 2.4是反对的。### 非常不鼓励使用虚拟内存！！# 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。# 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。## 要使用虚拟内存，只要把 &quot;vm-enabled&quot; 设置为 &quot;yes&quot;，并根据需要设置下面三个虚拟内存参数就可以了。vm-enabled no# vm-enabled yes# 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。## 最好的保存交换文件（被随机访问）的介质是固态硬盘（SSD）。## *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。# 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。vm-swap-file /tmp/redis.swap# &quot;vm-max-memory&quot; 配置虚拟内存可用的最大内存容量。# 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。## &quot;vm-max-memory&quot; 设置为0表示系统会用掉所有可用内存。# 这默认值不咋地，只是把你能用的内存全用掉了，留点余量会更好。# 例如，设置为剩余内存的60%-80%。vm-max-memory 0# Redis交换文件是分成多个数据页的。# 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。# 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。# 如果数据页太小，那用于存储的交换空间就会更少（假定你设置相同的数据页数量）## 如果你使用很多小对象，建议分页尺寸为64或32个字节。# 如果你使用很多大对象，那就用大一些的尺寸。# 如果不确定，那就用默认值 :)vm-page-size 32# 交换文件里数据页总数。# 根据内存中分页表（已用/未用的数据页分布情况），磁盘上每8个数据页会消耗内存里1个字节。## 交换区容量 = vm-page-size * vm-pages## 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。## 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。vm-pages 134217728# 同时可运行的虚拟内存I/O线程数。# 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。# 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。## 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。vm-max-threads 4############################### 高级配置 ################################ 当有大量数据时，适合用哈希编码（需要更多的内存），元素数量上限不能超过给定限制。# 你可以通过下面的选项来设定这些限制：hash-max-zipmap-entries 512hash-max-zipmap-value 64# 与哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。# 这种方式只有在符合下面限制的时候才可以用：list-max-ziplist-entries 512list-max-ziplist-value 64# 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。# 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。set-max-intset-entries 512# 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。# 这种编码只适合长度和元素都符合下面限制的有序序列：zset-max-ziplist-entries 128zset-max-ziplist-value 64# 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；# 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。## 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。## 建议：# 如果你对延迟比较在意的话就用 &quot;activerehashing no&quot;，每个请求延迟2毫秒不太好嘛。# 如果你不太在意延迟而希望尽快释放内存的话就设置 &quot;activerehashing yes&quot;。activerehashing yes################################## 包含 #################################### 包含一个或多个其他配置文件。# 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。# 包含文件特性允许你引人其他配置文件，所以好好利用吧。## include /path/to/local.conf# include /path/to/other.conf","categories":[{"name":"Redis","slug":"Redis","permalink":"http://abulo.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://abulo.github.io/tags/Redis/"}]},{"title":"Python DBUtils数据连接池与MySQL配合用法","slug":"Python-DBUtils数据连接池与MySQL配合用法","date":"2009-05-06T08:53:00.000Z","updated":"2019-01-06T09:03:59.729Z","comments":true,"path":"2009/05/06/Python-DBUtils数据连接池与MySQL配合用法/","link":"","permalink":"http://abulo.github.io/2009/05/06/Python-DBUtils数据连接池与MySQL配合用法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178# -*- coding: UTF-8 -*-&quot;&quot;&quot;desc:数据库操作类@note:1、执行带参数的ＳＱＬ时，请先用sql语句指定需要输入的条件列表，然后再用tuple/list进行条件批配２、在格式ＳＱＬ中不需要使用引号指定数据类型，系统会根据输入参数自动识别３、在输入的值中不需要使用转意函数，系统会自动处理&quot;&quot;&quot;import MySQLdbfrom MySQLdb.cursors import DictCursorfrom DBUtils.PooledDB import PooledDBimport Config&quot;&quot;&quot;Config是一些数据库的配置文件&quot;&quot;&quot;class Mysql(object): &quot;&quot;&quot; MYSQL数据库对象，负责产生数据库连接 , 此类中的连接采用连接池实现 获取连接对象：conn = Mysql.getConn() 释放连接对象;conn.close()或del conn &quot;&quot;&quot; #连接池对象 __pool = None def __init__(self): &quot;&quot;&quot; 数据库构造函数，从连接池中取出连接，并生成操作游标 &quot;&quot;&quot;# self._conn = MySQLdb.connect(host=Config.DBHOST , port=Config.DBPORT , user=Config.DBUSER , passwd=Config.DBPWD ,# db=Config.DBNAME,use_unicode=False,charset=Config.DBCHAR,cursorclass=DictCursor) self._conn = Mysql.__getConn() self._cursor = self._conn.cursor() @staticmethod def __getConn(): &quot;&quot;&quot; @summary: 静态方法，从连接池中取出连接 @return MySQLdb.connection &quot;&quot;&quot; if Mysql.__pool is None: __pool = PooledDB(creator=MySQLdb, mincached=1 , maxcached=20 , host=Config.DBHOST , port=Config.DBPORT , user=Config.DBUSER , passwd=Config.DBPWD , db=Config.DBNAME,use_unicode=False,charset=Config.DBCHAR,cursorclass=DictCursor) return __pool.connection() def getAll(self,sql,param=None): &quot;&quot;&quot; @summary: 执行查询，并取出所有结果集 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 &quot;&quot;&quot; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) if count&gt;0: result = self._cursor.fetchall() else: result = False return result def getOne(self,sql,param=None): &quot;&quot;&quot; @summary: 执行查询，并取出第一条 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 &quot;&quot;&quot; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) if count&gt;0: result = self._cursor.fetchone() else: result = False return result def getMany(self,sql,num,param=None): &quot;&quot;&quot; @summary: 执行查询，并取出num条结果 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param num:取得的结果条数 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 &quot;&quot;&quot; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) if count&gt;0: result = self._cursor.fetchmany(num) else: result = False return result def insertOne(self,sql,value): &quot;&quot;&quot; @summary: 向数据表插入一条记录 @param sql:要插入的ＳＱＬ格式 @param value:要插入的记录数据tuple/list @return: insertId 受影响的行数 &quot;&quot;&quot; self._cursor.execute(sql,value) return self.__getInsertId() def insertMany(self,sql,values): &quot;&quot;&quot; @summary: 向数据表插入多条记录 @param sql:要插入的ＳＱＬ格式 @param values:要插入的记录数据tuple(tuple)/list[list] @return: count 受影响的行数 &quot;&quot;&quot; count = self._cursor.executemany(sql,values) return count def __getInsertId(self): &quot;&quot;&quot; 获取当前连接最后一次插入操作生成的id,如果没有则为０ &quot;&quot;&quot; self._cursor.execute(&quot;SELECT @@IDENTITY AS id&quot;) result = self._cursor.fetchall() return result[0][&apos;id&apos;] def __query(self,sql,param=None): if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) return count def update(self,sql,param=None): &quot;&quot;&quot; @summary: 更新数据表记录 @param sql: ＳＱＬ格式及条件，使用(%s,%s) @param param: 要更新的 值 tuple/list @return: count 受影响的行数 &quot;&quot;&quot; return self.__query(sql,param) def delete(self,sql,param=None): &quot;&quot;&quot; @summary: 删除数据表记录 @param sql: ＳＱＬ格式及条件，使用(%s,%s) @param param: 要删除的条件 值 tuple/list @return: count 受影响的行数 &quot;&quot;&quot; return self.__query(sql,param) def begin(self): &quot;&quot;&quot; @summary: 开启事务 &quot;&quot;&quot; self._conn.autocommit(0) def end(self,option=&apos;commit&apos;): &quot;&quot;&quot; @summary: 结束事务 &quot;&quot;&quot; if option==&apos;commit&apos;: self._conn.commit() else: self._conn.rollback() def dispose(self,isEnd=1): &quot;&quot;&quot; @summary: 释放连接池资源 &quot;&quot;&quot; if isEnd==1: self.end(&apos;commit&apos;) else: self.end(&apos;rollback&apos;); self._cursor.close() self._conn.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://abulo.github.io/categories/Python/"},{"name":"MySQL","slug":"Python/MySQL","permalink":"http://abulo.github.io/categories/Python/MySQL/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://abulo.github.io/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://abulo.github.io/tags/MySQL/"},{"name":"DBUtils","slug":"DBUtils","permalink":"http://abulo.github.io/tags/DBUtils/"}]},{"title":"昨天的影院才是天堂影院","slug":"昨天的影院才是天堂影院","date":"2009-03-20T01:45:00.000Z","updated":"2019-01-06T08:33:44.898Z","comments":true,"path":"2009/03/20/昨天的影院才是天堂影院/","link":"","permalink":"http://abulo.github.io/2009/03/20/昨天的影院才是天堂影院/","excerpt":"","text":"这是一场关于梦想的电影往事。 二战时期的意大利西西里岛，既流传着一段美丽传说，也孕育着这么一个孩子的梦想：关于理想，关于友情，关于爱情，关于亲情。 电影梦 这个梦想是多多的，也是阿尔夫莱多的，更是朱塞佩·托纳托雷的。我不敢妄称多多就是朱塞佩·托纳托雷童年的幻像，但我知道朱塞佩·托纳托雷肯定也曾做过多多类似的梦——关于电影的梦。同样，那也曾是阿尔夫莱多的梦。阿尔夫莱多知道自己再没有圆梦的机会了，他要多多去圆梦，也是去圆他自己的梦。他不希望多多圆梦的途中会被打扰，会半途而废，甚至不惜于破坏多多与艾列娜的爱情来表示对梦想的虔诚，为多多画出这样一个美丽的梦境，将多多送了出去。他知道人在梦里是不能被打扰的，于是他在车站送行的时候狠狠的抓住多多：不准回来！不准想我们！不准回头！不准写信！不准妥协！忘了我们！ 友情梦 多多与阿尔夫莱多忘年的情谊，起源与古怪精灵的多多从阿尔夫莱多的放映室偷胶片开始。封建的神父作为影院的所有者，审片的态度一点也不马虎。胶片剪了又剪，多多的私藏也随着废弃胶片的增多而日益丰富，直至一天因胶片引发的意外火灾险些要了多多妹妹的命，阿尔夫莱多才意识到——这个小鬼原来有着和自己一样的梦，他要培养多多。但是阿尔夫莱多毕竟是成人，他知道多多不可能一辈子都做一名电影放映员，他告诉多多：“生活不是电影，生活比电影苦多了！”特别是在多多救了阿尔夫莱多的命之后，阿尔夫莱多更是将满心的希望都寄托在了多多的身上，他不仅像朋友，更像是父亲般的关爱着多多。最后当多多独自坐在影院欣赏阿尔夫莱多留给自己的遗物时，银幕上还能找到失落的东西，以作回忆的凭据，不免徒生无可奈何花落去的怅惘。 爱情梦 和大多数青春期男孩一样，多多邂逅了美丽的艾列娜，唠下了朝思夜想的心病。随后，寻着阿尔夫莱多故事中士兵足迹的多多，终于用毅力换来了艾列娜的爱情。可是在那样复杂的年代，怎么可能静的下心来谈爱情？何况多多还背负着阿尔夫莱多的电影梦。三十年后多多重归故里，慕然回首，看见梦中人伫立街头，斑斑银发随风飘舞，怎一个感伤了得。当天晚上，这对有情人终于圆了自己三十年前的梦。第二天多多要离开了，挂电话给艾列娜，刚要设想幸福的将来，却被艾列娜打住： “不，没有将来了，只有过去，昨晚只是一场梦而已，一个美好的梦。是我们小时候没实现的梦。。。我想，没有比这样更好的结局了。” 亲情梦 影片的开始就是多多的母亲在给多多挂电话。三十年了，三十年多多都没有回来，没有回来一次看望自己的母亲和妹妹。这次阿尔夫莱多去世，多多应该回来了。餐桌上，多多为自己三十年来对家庭的不闻不问进行忏悔，母亲宽容的摇摇头：“我从未要求，你也无需解释。”接着母亲给多多讲了他小时侯关于门锁的故事，多多沉默不语。三十年了，妹妹对他觉得陌生了，而母亲的爱，却始终没有改变。多多知道，母亲在梦了都盼望着他会在某一天的晚上突然回来。 梦终会醒，可是电影要继续，生活也要继续。 电影就是将平淡无奇的镜头都剪去以后的人生。","categories":[{"name":"影评","slug":"影评","permalink":"http://abulo.github.io/categories/影评/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://abulo.github.io/tags/电影/"}]},{"title":"英雄和英雄","slug":"英雄和英雄","date":"2008-11-14T16:44:00.000Z","updated":"2019-01-06T08:34:37.262Z","comments":true,"path":"2008/11/15/英雄和英雄/","link":"","permalink":"http://abulo.github.io/2008/11/15/英雄和英雄/","excerpt":"","text":"阿喀琉斯，以前总会唾弃之，他的出色才能，使得野蛮的斯巴达士兵们躲在木马中潜入特洛伊，然后上演对于一个无比文明的国家毁灭性的屠城！他不受暴君的约束，有自己的辨识能力，也有自己独立的个性，当然，更加拥有的，是当时时代下生存和被崇拜的力量——武力，他的格斗术和如此的个性，决定了他只能成为一个英雄，而不是一个君主。 ­ 故事很老土，就是因为特洛伊的二王子，也就是悲剧英雄赫克托耳的弟弟，勾引了希腊第一美女“水性杨花”的海伦，引发了希腊和特洛伊的一场战争。阿喀琉斯，为了自己成为历史上不朽的英雄而被希腊君主利用而战；赫克托耳，为了保护自己那个懦弱不敢承担责任（或者说没有能力承担责任）的弟弟，以及为了保护自己所热爱的子民们而战斗！ ­ 英雄和英雄相遇之际就擦出了火花，他们甚至开始不伤害彼此（虽然也有一些政治因素在此）。而赫克托耳的美丽的表妹被希腊人俘虏后，与阿喀琉斯迸出了爱情的火花，短短的几天内，差点改变一个英雄的铸就，她像刀鞘一样，差点就保护了国家的一切！可是被政治利用了的战争中，永远都是那么不尽人意，赫克托耳错杀了阿喀琉斯的堂弟。命运弄人，最终这个身来就神赐予力量的阿喀琉斯，重上战场，赫克托耳——一个国家的精神支柱就败死在阿喀琉斯的手下！特洛伊就此而没有了胜算。而在之后的木马屠城中，这个可怜的英雄，又死于红颜祸水。虽然有复仇的快感，却也因为阿喀琉斯的死亡而抱憾而叹…… ­ 这就是英雄与英雄！ ­","categories":[{"name":"影评","slug":"影评","permalink":"http://abulo.github.io/categories/影评/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://abulo.github.io/tags/电影/"}]},{"title":"The Legend of 1900","slug":"The-Legend-of-1900","date":"2008-10-21T13:59:00.000Z","updated":"2019-01-06T08:34:49.620Z","comments":true,"path":"2008/10/21/The-Legend-of-1900/","link":"","permalink":"http://abulo.github.io/2008/10/21/The-Legend-of-1900/","excerpt":"","text":"生命像极了一场茫无头绪的冒险，所以我们往往会敬佩那些流连于同一个地方，专注于同一件事情的人。被无常的命运折磨的时候，拒绝改变有时候能提供给人一种安全感。所以《海上钢琴师》从一开始便给了我们很多期待。一个被遗弃在巨型渡轮上的孤儿突然间成了天才的钢琴师，他一辈子都不曾下过这艘船。海、船、来来往往的两千名乘客和他的钢琴构成了他唯一的世界。 ­ 1900的音乐是和他心底始终保有的那些价值分不开的，他弹琴很大程度上是为了不离开他内心那个与世隔绝的世界。但没有印证我们内心的期待，我们不知道这个男人在想什么？他是个英雄还是个疯子？最后那段小号演奏仿佛是在追忆些什么。是的，也许的确是在追忆些什么，但，凭什么追忆呢？ 人是惧怕新环境的，就像我们总喜欢蹲在自己被窝里添伤口一样，我们不只是不想让别人看到自己伤心，还因为我们怀念被子熟悉的味道。。一旦空质量变了，我们的心也就飘荡不定了。。是没有勇气还是我们习惯安逸？是没有本钱还是害怕失败？没有答案，一切都在发生，一切都流逝，生就是死的一部分罢了。。。就像双腿蹲在马桶上一样这么的不可思议又切实存在！ ­ “Max,我在想我用两只手弹出的音乐，我只希望天堂里也有钢琴！”­","categories":[{"name":"影评","slug":"影评","permalink":"http://abulo.github.io/categories/影评/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://abulo.github.io/tags/电影/"}]},{"title":"这就是我","slug":"这就是我","date":"2008-03-28T07:27:00.000Z","updated":"2019-01-06T07:29:27.674Z","comments":true,"path":"2008/03/28/这就是我/","link":"","permalink":"http://abulo.github.io/2008/03/28/这就是我/","excerpt":"","text":"顽石无材补苍天 ­ 沦落凡尘二十年 ­ 修成正果还夙愿 ­ 可否邂逅女娲仙 ­ 青城峰下，顽石无材，奈何补苍天？ ­ 余，本一顽石，出自寒门，历二十载，沐山川之灵秀，秉日月之精华，终修成正果，甲申年秋，忝列金榜，得以游学于蓉城。学业既成，足迹遍及川而不得遂其愿也。为衣食计，丁亥年夏，仍郁郁不得志。 ­ 本人爱好甚广 ­ 【$，￥，篮球，足球，台球】 ­ 其余【电脑游戏，饶舌，贫，喝酒，…………】 ­ 本人梦境【愿望理想】混之而言出：“世上出于乌托邦，愿生活于那圣地，步入天堂，漫过神圣走廊，天使笑容让我感到无比慈祥，内心深感舒畅，此地人皆平等，无暴力，纠纷与偏见，至今仍留恋此梦”不安于现状。偶个性隐于开朗之说又隐于内向之说，全仗射手星之罩，宙斯为之袒护，天神四方，不惧万物，乃“天才”自称。口语常念“静享天赐安眠”，自知知足长乐。 ­ 文章本天成，妙手偶得。奉上，不揣固陋，诚惶诚恐。­","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://abulo.github.io/categories/杂谈/"}],"tags":[]}]}