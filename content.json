{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Abulo Hoo","url":"http://abulo.github.io"},"pages":[{"title":"关于","date":"2019-01-06T09:27:10.000Z","updated":"2019-01-06T09:55:05.496Z","comments":false,"path":"about/index.html","permalink":"http://abulo.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: &apos;abulo&apos; age: 32, gender: &apos;男&apos;, profession: &apos;Developer&apos;, experience: &apos;10年+&apos;, address: &apos;四川省成都市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/abulo&apos;, blog: &apos;http://abulo.github.io&apos;, email: &apos;abulo.hoo@gmail.com&apos;, description: &apos;致力于Web后端开发交互&apos;, skills: [ [&apos;PHP&apos;, &apos;Swoole&apos;,&apos;Python&apos;,&apos;Golang&apos;], [&apos;Git&apos;, &apos;SVN&apos;], [&apos;MySQL&apos;,&apos;Redis&apos;] ], devTools: [ [&apos;Sublime Text&apos;, &apos;Visual Studio Code&apos;], [&apos;Chrome DevTools&apos;, &apos;Fiddler&apos;], [&apos;SourceTree&apos;, &apos;TortoiseSVN&apos;], [&apos;SwitchHosts&apos;], [&apos;Navicat&apos;, &apos;XAMPP&apos;], ]&#125;"},{"title":"友情链接","date":"2019-01-06T10:13:24.940Z","updated":"2019-01-06T10:13:24.940Z","comments":true,"path":"links/index.html","permalink":"http://abulo.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-01-06T09:54:59.325Z","updated":"2019-01-06T09:54:59.325Z","comments":false,"path":"books/index.html","permalink":"http://abulo.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-01-06T09:54:52.610Z","updated":"2019-01-06T09:54:52.610Z","comments":false,"path":"categories/index.html","permalink":"http://abulo.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-01-06T10:00:48.252Z","updated":"2019-01-06T10:00:48.252Z","comments":false,"path":"repository/index.html","permalink":"http://abulo.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-06T10:18:35.397Z","updated":"2019-01-06T10:18:35.397Z","comments":false,"path":"tags/index.html","permalink":"http://abulo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang 工程管理","slug":"Golang-工程管理","date":"2019-05-16T01:31:00.000Z","updated":"2019-05-16T01:32:52.594Z","comments":true,"path":"2019/05/16/Golang-工程管理/","link":"","permalink":"http://abulo.github.io/2019/05/16/Golang-工程管理/","excerpt":"","text":"Golang 工程管理Golang 语言的库区分内置库和第三方库。内置库，下载安装Golang 既可以使用，第三方库的使用，我们需要获取到本地，再使用。 包的导入和管理，讲述的是在Golang 里如何进行内置库的使用和第三方库的导入使用，管理则指的是在自己构建的工程里如何管理第三方库。 1. 工作空间GOPATH 即是项目的工程的目录GOROOT 即是go 源代码的目录 工作空间由：src、bin、pkg 三个目录组成。通常会把空间的目录设置为GOPATH。 大致的目录结构如下： 123456workspace src github.com op bin pkg 我们一般关心的是 src 目录下的文件，包括：第三方库和自己创建的项目我们需要创建目录就在GOPATH/src 下创建文件夹。 2. 包导入 内置包导入 第三方包的导入 原则就是：在src 下的文件的路径比如：导入内置包 fmt12345import fmtfunc main()&#123; fmt.Println(\"hello world\")&#125; 比如：导入第三方库 cli12345678910import ( \"os\" \"github.com/urfave/cli\")func main() &#123; app := cli.NewApp() app.Run(os.Args)&#125; 表示：cli 源代码在：GOPATH/src/github.com/urfave/cli 路径下 导入自己写的包：12345678import ( \"jianshu-go\")func main() &#123; jianshu.NewSpecialSubject(\"\")&#125; 表示：jianshu-go 在 GOPATH/src/jianshu-go 强调一点：golang 中，使用到的包需要导入，不使用的包导入，编译过程会报错。这一点和 python 很不一样。 好，上文已经知道了包的导入：即以GOPATG/src 为基本路径导入完整路径即可。虽然 golang 也支持相对路径导入，但不建议。 上文是一种包的默认导入方式。还存在下面几种： 别名 1234567package mainimport name \"fmt\"func main() &#123; name.Println()&#125; 即：重新给包命别名，上文中 name 替换了默认的 fmt 名称 省略包名 1234567package mainimport . \"fmt\"func main() &#123; Println(\"hello world\")&#125; 即：省略包名，用点号省略包名。所以包内的函数、方法、结构体和变量等的使用直接写函数、方法、结构体、变量等的名称。 只导入不使用123456package mainimport _ \"fmt\"func main() &#123;&#125; 上文提到，golang 中导入的包需要使用。否则会报错。上文的例子，使用_ 表示只导入，而不使用。通常用于只是执行那个需要导入包的 init 函数。 梳理下： 12345import name &quot;fmt&quot; # name.Println 别名方式import _ &quot;fmt&quot; # 只初始化目标包import . &quot;fmt&quot; # 省略包名import &quot;fmt&quot; # fmt.Println 原始包名+方法(函数)虽然存在几种方式。但是推荐使用默认方式：即原始包全路径的方式。其他方式，使用到的时候能更好的组织你的代码，那就用。否则不建议使用。 3. 包下载使用 go 自带的 命令行工具go get -u -v *go get 后面接的参数即是：github 或者其他托管网站的代码路径。 下载的第三方库的默认路径是：GOPATH/src 路径 ###4. 包管理通过上文，我们已经知道如何导入包、导入包的几种方式、第三方包的下载、下载包的存放路径等。 那自己创建的项目中如何管理第三方包呢? 即：将用到的第三方包移至个人项目工程下。govendor 。虽然存在多种包的管理方式。但我觉得现在的这种方式挺友好的。下载go get -u github.com/kardianos/govendor govendor init这一步触发的动作是创建：vendor 目录 和 vendor.json 文件 govendor add +external这一步触发的动作是：将自己项目中使用到的第三方库，复制到vendor 目录下，并维护vendor.json文件 go 的工作空间的文件系统组成go 中包的导入方式go 中第三方包的管理","categories":[{"name":"golang","slug":"golang","permalink":"http://abulo.github.io/categories/golang/"}],"tags":[{"name":"Golang 工程管理","slug":"Golang-工程管理","permalink":"http://abulo.github.io/tags/Golang-工程管理/"}]},{"title":"Golang 错误处理","slug":"Golang-错误处理","date":"2019-05-16T01:19:00.000Z","updated":"2019-05-16T01:20:21.128Z","comments":true,"path":"2019/05/16/Golang-错误处理/","link":"","permalink":"http://abulo.github.io/2019/05/16/Golang-错误处理/","excerpt":"","text":"Golang 错误处理 err 变量 error 接口 panic recover 、defer 0. err在 Golang 中如果需要进行错误处理，一般都默认函数的最后一个返回值是 err。 比如： 123func example(arg int) (int, error) &#123; return arg + 1, nil&#125; 再比如看内置读取文件的ioutil.ReadAll 的定义123func ReadAll(r io.Reader) ([]byte, error) &#123; return readAll(r, bytes.MinRead)&#125; 可以看出，一般函数的最后一个返回值定义为 err, 可以通过这个错误信息判断函数是否执行正确。 1. error 接口123type error interface &#123; Error() string&#125; 内置 errors 包实现了这个接口：123456789101112131415161718192021package errors// New returns an error that formats as the given text.func New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;// errorString is a trivial implementation of error.type errorString struct &#123; s string&#125;// 实现了 error 接口的Error 方法func (e *errorString) Error() string &#123; return e.s&#125;// 带格式输出的 error func Errorf(format string, a ...interface&#123;&#125;) error &#123; return errors.New(Sprintf(format, a...))&#125; 所以可以通过下面两种方法创建包含错误文本的 error 对象： errors.New fmt.Errorf 带格式化输出的 error 对象 123456789101112// errors.Newfunc exampleReadAllError() error &#123; _, err := ioutil.ReadAll(nil) return err&#125;// fmt.Errorffunc exampleErrorf(arg int) error &#123; return fmt.Errorf(\"%d\", arg)&#125; 2. panic在 golang 中遇到错误，需要强制退出程序，可以使用 panic 。panic 接收的参数是任意类型。1func panic(v interface&#123;&#125;) 12345678910111213141516func examplePanic() &#123; panic(nil)&#125;func main()&#123; examplePanic()&#125;&gt;&gt;&gt;panic: nilgoroutine 1 [running]:main.examplePanic() C:/Users/abulo/go/src/go-example-for-live/five_learning/main.go:28 +0x3amain.main() C:/Users/abulo/go/src/go-example-for-live/five_learning/main.go:37 +0x27 上文中调用 examplePanic 函数会抛出异常，直接终止程序的执行。panic 传入的参数是错误信息。比如上文 nil 除非你确定需要终止程序运行，否则不要使用 panic 3. recoverrecover 可以接收返回的异常信息，通常和 defer 一起使用。 123456789101112131415func examplePanic() &#123; panic(\"123\")&#125;func main() &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(fmt.Sprintf(\"recieve error: %s\", err)) &#125; &#125;() examplePanic()&#125;&gt;&gt;&gt;recieve error: 123 上文操作后，examplePanic 抛出的异常被 recover 接收到，再进行了后面的处理。上文执行就没有错误提示。 当多个 panic 抛出异常是， recover 接收第一个 panic 抛出的异常。1234567891011121314151617181920212223func examplePanic() &#123; panic(&quot;123&quot;)&#125;func examplePanicOther() &#123; panic(&quot;1234&quot;)&#125;func main() &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(fmt.Sprintf(&quot;recieve error: %v&quot;, err)) &#125; &#125;() examplePanic() examplePanicOther() examplePanic()&#125;&gt;&gt;&gt;recieve error: 123","categories":[{"name":"golang","slug":"golang","permalink":"http://abulo.github.io/categories/golang/"}],"tags":[{"name":"Golang 错误处理","slug":"Golang-错误处理","permalink":"http://abulo.github.io/tags/Golang-错误处理/"}]},{"title":"Golang 结构体","slug":"Golang-结构体","date":"2019-05-10T08:50:00.000Z","updated":"2019-05-10T08:51:16.687Z","comments":true,"path":"2019/05/10/Golang-结构体/","link":"","permalink":"http://abulo.github.io/2019/05/10/Golang-结构体/","excerpt":"","text":"Golang 结构体前言 Golang 中用来表示单一的数据类型可以使用 变量声明的方式 比如：123var Number intvar Married boolvar Name string 同一数据类型的集合可以使用下面的变量声明方式 比如：123var Infor map[string]stringvar Names []stringvar Number [10]int 如果需要表示不同的数据类型的集合集需要使用结构体 结构体可以用来表示不同的数据类型的集合, 同时可以表示用户自定义类型。 定义及声明 按顺序初始化 按任意顺序初始化 字段赋值 new 函数分配指针 标签 字段访问 方法：值传递和指针传递 函数和方法的区别 组合：内嵌结构体、内嵌匿名成员 格式化显示结构体 1.定义及声明type 和 struct 关键字构成结构体的声明。在 Golang 中， 结构体可以当做是一种数据类型。所以可以这样这样操作:12type Name struct&#123;&#125;var Infor Name 另外，结构体在 golang 中的作用又可以当做类,所以又存在方法123456type Name struct &#123;&#125;func (n Name) ResponseNumber() int &#123; return 1&#125; 调用结构体方法是使用 点号.1234func main() &#123; var name Name name.ResponseNumber()&#125; 声明示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465type Information struct &#123; Name string Age int School string Married bool Habits []string Infor map[string]string&#125;func exampleInformationDeclare() &#123; // one var ( exampleInformationOne Information Infor map[string]string ) Infor = make(map[string]string) Infor[\"key\"] = \"hello-world\" exampleInformationOne = Information&#123; \"abulo\", 18, \"shanghaiUniversity\", true, []string&#123;\"1\", \"2\", \"3\"&#125;, Infor, &#125; fmt.Println(exampleInformationOne, exampleInformationOne.Name) // two var exampleInformationTwo Information exampleInformationTwo.Name = \"golang\" exampleInformationTwo.School = \"Google\" exampleInformationTwo.Age = 10 exampleInformationTwo.Infor = Infor fmt.Println(exampleInformationTwo, exampleInformationTwo.Married) // three var exampleInformationThree Information exampleInformationThree = Information&#123; Name: \"Python\", School: \"Gudio school\", Age: 18, Habits: []string&#123;\"1\", \"2\"&#125;, Infor: Infor, Married: true, &#125; fmt.Println(exampleInformationThree, exampleInformationThree.School) // four var exampleInformationFour *Information exampleInformationFour = new(Information) exampleInformationFour.Name = \"Java\" fmt.Println(exampleInformationFour, exampleInformationFour.School)&#125;func main() &#123; exampleInformationDeclare()&#125;输出:&#123;abulo 18 shanghaiUniversity true [1 2 3] map[key:hello-world]&#125; abulo&#123;golang 10 Google false [] map[key:hello-world]&#125; false&#123;Python 18 Gudio school true [1 2] map[key:hello-world]&#125; Gudio school&amp;&#123;Java 0 false [] map[]&#125; 2.标签带标签的结构体的定义，在转换为json格式的数据的时候会自动将对应的字段转换为标签中的字段: 比如: Name 转换成 name 字段 标签字段不能在编程中实际使用 比如：可以这样: InformationWithLabel.Name 不可以这样：InformationWithLabel.name 1234type InformationWithLabel struct &#123; Name string `json:\"name\"` Age int `json:\"age\"`&#125; 3. 字段的访问结构体内的是一系列相关字段的集合。可以使用点号.获取结构体的字段。 12345678910111213141516type InformationWithLabel struct &#123; Name string `json:\"name\"` Age int `json:\"age\"`&#125;func exampleInformationWithLabelFiled() &#123; var example InformationWithLabel example = InformationWithLabel&#123; Name: \"abulo\", Age: 18, &#125; fmt.Println(example.Name, example.Age)&#125;输出:abulo 18 4. 方法Golang 中结构体相当于面向对象中的类,所以存在方法。方法根据传入的参数的不同，又分为：值传递 和 指针传递。两者的效果就是：值传递不可改变值，指针传递可以改变值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061type Response struct &#123; Code int Result []byte Headers map[string]string&#125;func (r Response) GetAttrCode() int &#123; return r.Code&#125;func (r Response) GetAttrResult() []byte &#123; return r.Result&#125;func (r Response) GetAttrHeader() map[string]string &#123; return r.Headers&#125;func (r *Response) SetCode(code int) &#123; r.Code = code&#125;func (r *Response) SetHeaders(key, value string) &#123; r.Headers[key] = value&#125;func exampleResponse() &#123; var ( response Response headers map[string]string ) headers = make(map[string]string) headers[\"Server\"] = \"GitHub.com\" headers[\"Status\"] = \"Ok\" response.Headers = headers response.Code = 200 response.Result = []byte(\"hello world\") fmt.Println(response.GetAttrCode()) fmt.Println(response.GetAttrHeader()) fmt.Println(response.GetAttrResult()) response.SetCode(404) fmt.Println(response) response.SetHeaders(\"Status\", \"failed\") fmt.Println(response)&#125;func main() &#123; exampleResponse()&#125;&gt;&gt;&gt;200map[Server:GitHub.com Status:Ok][104 101 108 108 111 32 119 111 114 108 100]&#123;404 [104 101 108 108 111 32 119 111 114 108 100] map[Server:GitHub.com Status:Ok]&#125;&#123;404 [104 101 108 108 111 32 119 111 114 108 100] map[Status:failed Server:GitHub.com]&#125; 可以看出： 结构体的方法如何定义 值传递的适用于取值 指针传递适用于更改字段的值同时 方法和普通的函数的定义又有些许的不同。 5. 函数和方法的区别Golang 中函数和方法存在区别。 123456789func NormalFunc(arg int) int &#123; return arg + 1&#125;func (r *Response) SetCode(code int) &#123; r.Code = code&#125; Go 方法是作用在接收者（receiver）上的一个函数。接收者可以是几乎任何类型。 但一般选择 结构体 作为接收者 6. 组合匿名字段在 Golang 中可以通过结构体的组合实现类的继承。 即：将一个结构体A当成另一个结构体B的匿名字段，则 这个结构体B自动拥有A的所有字段和方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061type Response struct &#123; Code int Result []byte Headers map[string]string&#125;func (r Response) GetAttrCode() int &#123; return r.Code&#125;func (r Response) GetAttrResult() []byte &#123; return r.Result&#125;func (r Response) GetAttrHeader() map[string]string &#123; return r.Headers&#125;func (r *Response) SetCode(code int) &#123; r.Code = code&#125;func (r *Response) SetHeaders(key, value string) &#123; r.Headers[key] = value&#125;type Requests struct &#123; Url string Params string&#125;type CollectionRequests struct &#123; CollectionNumber int Requests Response&#125;func exampleCollectionRequests() &#123; var collectionRequests CollectionRequests collectionRequests.CollectionNumber = 10 collectionRequests.Url = \"https://www.example.com\" collectionRequests.Params = \"name\" collectionRequests.Code = 201 collectionRequests.Result = []byte(\"hello Golang\") var headers map[string]string headers = make(map[string]string) headers[\"status\"] = \"Good\" collectionRequests.Headers = headers fmt.Println(collectionRequests) fmt.Println(collectionRequests.GetAttrCode())&#125;func main() &#123; exampleCollectionRequests()&#125;&gt;&gt;&gt;&#123;10 &#123;https://www.example.com name&#125; &#123;201 [104 101 108 108 111 32 71 111 108 97 110 103] map[status:Good]&#125;&#125;201 上文CollectionRequests 拥有两个匿名字段Requests、Response ，则自动拥有这个两个结构体的字段和方法 内嵌结构体这个组合的形式会遇到两个问题： 字段相同怎么办？即结构体A 有字段 a, 结构体 B 也有字段 a。怎么处理？ 方法相同怎么办？即结构体A 有方法 methodOne, 结构体 B 也有方法 methodOne。怎么处理？应该尽量避免命名冲突。同时可以使用多个点号的方法访问字段。方法则优先使用结构体B 的。 123456789101112131415161718192021222324252627type OtherRequests struct &#123; Request Requests Resp Response Code int&#125;func (o OtherRequests) GetAttrCode() &#123; fmt.Println(fmt.Sprintf(\"Outer Code = %d\", o.Code)) fmt.Println(fmt.Sprintf(\"inner Code = %d\", o.Resp.Code))&#125;func exampleOtherRequests() &#123; var other OtherRequests other.Code = 201 other.Resp.Code = 202 fmt.Println(other) other.GetAttrCode() fmt.Println(other.Resp.GetAttrCode())&#125;func main() &#123; exampleOtherRequests()&#125;&gt;&gt;&gt;&#123;&#123; &#125; &#123;202 [] map[]&#125; 201&#125;Outer Code = 201inner Code = 202202 可以看出通过组合结构体的方式，可以实现类中的继承和多态。 7. 格式化显示结构体Golang 中只需要实现一个名为 String 的方法即可格式化显示结构体 12345678910111213141516171819202122232425262728type OtherRequests struct &#123; Request Requests Resp Response Code int&#125;func (o OtherRequests) String() string &#123; return fmt.Sprintf(\"Request = %v , Response = %v , Code = %d\", o.Request, o.Resp, o.Code)&#125;func exampleOtherRequests() &#123; var other OtherRequests other.Code = 201 other.Resp.Code = 202 fmt.Println(other) other.GetAttrCode() fmt.Println(other.Resp.GetAttrCode())&#125;func main() &#123; exampleOtherRequests()&#125;&gt;&gt;&gt;Request = &#123; &#125; , Response = &#123;202 [] map[]&#125; , Code = 201Outer Code = 201inner Code = 202202","categories":[{"name":"golang","slug":"golang","permalink":"http://abulo.github.io/categories/golang/"}],"tags":[{"name":"Golang 结构体","slug":"Golang-结构体","permalink":"http://abulo.github.io/tags/Golang-结构体/"}]},{"title":"Golang 函数","slug":"Golang-函数","date":"2019-05-06T01:27:00.000Z","updated":"2019-05-06T01:28:31.278Z","comments":true,"path":"2019/05/06/Golang-函数/","link":"","permalink":"http://abulo.github.io/2019/05/06/Golang-函数/","excerpt":"","text":"Golang 函数重点 函数的定义 参数：定参，不定参数 返回值：单个返回值，多个返回值， 命名返回值 值传递和指针传递 函数作为参数 匿名函数 main 函数 和 init 函数 函数的定义关键字 func 12345678// 声明函数func example() &#123; fmt.Println(\"Hello world\")&#125;// main函数func main() &#123; example()&#125; 参数：定参，不定参数1234567891011121314151617// 定参func exampleOneArg(arg int) &#123; fmt.Println(arg + 1)&#125;// 不定参数func exampleListArg(args ...int) &#123; for index, value := range args &#123; fmt.Println(index, value) &#125;&#125;// mainfunc main() &#123; exampleOneArg(12) exampleListArg(1, 2, 3, 4, 5)&#125; 返回值：单个返回值，多个返回值， 命名返回值1234567891011121314151617181920// 一个返回值func exampleOneResponse(arg int) int &#123; return arg*100 + 1&#125;// 两个返回值func exampleTwoResponses(arg int) (int, int) &#123; return arg * 10, arg * 100&#125;// 命名返回值func exampleNameResponse(arg int) (sum int) &#123; sum = arg * 1000 return&#125;// mainfunc main() &#123; exampleOneResponse(10) exampleTwoResponses(10) exampleNameResponse(10)&#125; 值传递和指针传递值传递和指针传递针对的是函数的传入参数究竟是拷贝入参的值进行操作还是拷贝入参的内存地址，带来的效果就是一个能改变传入的参数的值，一个不能改变传入参数的值。 123456789101112131415161718// 值传递func exampleValueCopy(arg int) int &#123; arg = arg + 1 return arg&#125;// 指针传递func exampleValueAddress(arg *int) int &#123; *arg = *arg + 1 return *arg&#125;// mainfunc main() &#123; var arg int = 10 exampleValueCopy(arg) fmt.Println(arg) // 10 exampleValueAddress(&amp;arg) fmt.Println(arg) // 11&#125; 函数作为参数1234567891011// func as argfunc funcArg(arg int) int &#123; return arg * 100&#125;func exampleFuncAsArg(arg int, function func(int) int) int &#123; return arg + function(arg)&#125;// mainfunc main() &#123; fmt.Println(exampleFuncAsArg(10, funcArg)) // 1010&#125; 匿名函数123456// un name funcvar NoNameFunc = func(arg int) int &#123; return arg * 1000 &#125;// mainfunc main() &#123; fmt.Println(NoNameFunc(10)) // 10000&#125; main 函数 和 init 函数 这两个函数没有入参和返回值 一个工程有且只有一个 main 函数作为程序的主入口 一个工程可以有多个init 函数，执行顺序和包的导入顺序相关","categories":[{"name":"golang","slug":"golang","permalink":"http://abulo.github.io/categories/golang/"}],"tags":[{"name":"函数","slug":"函数","permalink":"http://abulo.github.io/tags/函数/"}]},{"title":"Golang 基础知识","slug":"Golang-基础知识","date":"2019-05-05T04:55:00.000Z","updated":"2019-05-05T06:55:52.442Z","comments":true,"path":"2019/05/05/Golang-基础知识/","link":"","permalink":"http://abulo.github.io/2019/05/05/Golang-基础知识/","excerpt":"","text":"Golang 基础知识Golang 的基础知识。主要包括： 变量 常量 字符串 数组 切片 Map 结构体 函数 方法 分支 循环 变量变量的注意事项有下面几点： 命名原则： 见文知意 规范：Golang 中采用驼峰式标准：numberOfClass 首字母大写：外部可访问；首字母小写：内部访问 长度适中 避免使用关键字 123var ok boolvar value stringvar number int 声明及初始化原则： 明确数据类型 少使用隐式声明 12345# Bettervar Name string# No GoodName := \"abulo\" PS 在函数内部可以使用 := 初始化，自动判断变量的类型。但是建议使用显式声明 使用原则： 变量声明，靠近使用处： 即你需要使用变量就在要使用的地方声明变量，而不是提前声明一大堆，或者远离使用变量的地方，不利于阅读 多个变量声明放一起 12345678910var ( url string result []byte err error )url = \"http://www.baidu.com\"if result, err = http.Get(url); err!=nil&#123; // do something&#125; 常用的布尔值变量名称: donefoundoksuccessflag 使用对仗： begin/startfirst/lastlocked/unlockedmin/maxnext/previousold/newopened/closedvisible/invisiblesource/targetsource/destinationup/down 常量常量注意这几点：12关键字：constconst AppName = \"App\" 字符串12345678910111213#短的var Help stringHelp = \"Thank you for Your help.\"#长的var HelpMessage string HelpMessage = `Hello Everone: Welcome to here. Today, we will learn how to learn golang.` 字符串常用的操作：库： strings内置库的使用注意两点： 函数的输入值及类型 函数的输出值及类型 Contains:判断是否包含字符串 1func Contains（s，substr string）bool Count:输出字符串中自字符的个数 1func Count（s，sep string）int Index:返回字符第一次出现的位置，不存在返回-1 1func Index（s，sep string）int Join:按给定的分隔符拼接一个字符串切片成字符串 1func Join（a []string，sep string）string LastIndex:子串最后一次出现的位置 1func LastIndex（s，sep string）int ToLower:将字符串全部小写 1func ToLower（s string）string ToUpper:将字符串全部大写 1func ToUpper（s string）string Repeat:重复字符串 1func Repeat（s string，count int）string Replace:替换 1func Replace（s，old，new string，n int）string TrimSpace:去除字符串前后空格 1func TrimSpace（s string）string Split:切割 1func Split（s，sep string）[]string 数组固定长度列表在Golang 里称之为数组.长度不固定的里称之为切片.12var NumberList = [3]stringNumberList = [3]string&#123;\"Python\", \"Golang\", \"PHP\"&#125; 获取数组长度: len获取数组容量: cap编程中,凡是可以使用if…else的都可以使用数组来遍历,再对遍历的值进行操作. 切片相当于不固定长的数组. 可以初始设置容量, 超过容量后,自动扩充. len 获取长度cap 获取容量 常用的操作: slice 123456789101112func main()&#123; var ( value []string ) value = []string&#123; \"aa\", \"bb\", \"cc\", &#125; fmt.Print(value[1:])&#125;输出:[bb cc] append 12345678910111213func main()&#123; var ( value []string ) value = []string&#123; \"aa\", \"bb\", \"cc\", &#125; value = append(value, \"dd\") fmt.Println(value)&#125;输出:[aa bb cc dd] range遍历 123456789101112131415161718func main()&#123; var ( value []string ) value = []string&#123; \"aa\", \"bb\", \"cc\", &#125; for index, i:= range value&#123; fmt.Println(index, i) &#125;&#125;输出0 aa1 bb2 cc Map字典: 键值型 声明 1234567891011121314func mapDeclare(key string, value string)map[string]interface&#123;&#125;&#123; var ( body map[string]interface&#123;&#125; ) body = make(map[string]interface&#123;&#125;) body[key] = value return body&#125;func main()&#123; fmt.Println(mapDeclare(\"name\", \"abulo\"))&#125;输出:map[name:abulo] 遍历 123456789101112131415161718func main()&#123; var ( body map[string]interface&#123;&#125; ) body = make(map[string]interface&#123;&#125;) body[\"name\"] = \"abulo\" body[\"age\"] = 32 body[\"university\"] = \"SiChuanNormalUniversity\" rangeMap(body)&#125;func rangeMap(body map[string]interface&#123;&#125;) &#123; for key, value := range body&#123; fmt.Println(key, value) &#125;&#125;name abuloage 32university SiChuanNormalUniversity 结构体结构体在 Golang 里面的作用非常大 即是数据类型 又可以有方法 作用相当于其他语言的类. 声明12345678910111213141516171819type MyExample struct &#123; Name string Age int School string&#125;func declare()&#123; var ( exampleStruct MyExample ) exampleStruct.Name = \"abulo\" exampleStruct.Age = 32 exampleStruct.School = \"SiChuanNormalUniversity\" fmt.Println(exampleStruct)&#125;func main()&#123; declare()&#125;&#123;abulo 32 SiChuanNormalUniversity&#125; 方法:值传递 一般获取值:1func (m MyExample) GetAttrName()string 指针传递一般改变值:1func (m *MyExample) SetAttrAge(newAge int) 栗子:1234567891011121314151617181920212223242526272829303132333435type MyExample struct &#123; Name string Age int School string&#125;func declare() MyExample &#123; var ( example MyExample ) example.Name = \"abulo\" example.Age = 32 example.School = \"SiChuanNormalUniversity\" fmt.Println(example) return example&#125;func (m MyExample) GetAttrName()string&#123; return m.Name&#125;func (m *MyExample) SetAttrAge(newAge int)&#123; m.Age = newAge&#125;func main()&#123; test := declare() fmt.Println(test.GetAttrName()) fmt.Println(test) test.SetAttrAge(18) fmt.Println(test)&#125;&#123;abulo 32 shanghaiUniversity&#125;abulo&#123;abulo 32 shanghaiUniversity&#125;&#123;abulo 18 shanghaiUniversity&#125; 匿名字段 即隐式的引入一个结构体的所有字段12345678type MyExample struct &#123; Name string Age int School string&#125;type OtherExample struct &#123; MyExample&#125; OtherExample 自动拥有 Name, Age, School 字段 函数函数分为这麽几类: 匿名函数 结构体的方法 普通函数 要写好函数注意下面几点: 函数名称: 见文知意 参数 返回值 匿名函数: 即没有名称的函数, 字面意思, 一般用来处理简单的函数12345func main()&#123; var NoNameFunc = func(name string) &#123;fmt.Println(name)&#125; NoNameFunc(\"abulo\")&#125; 普通函数123456789func GetMaxNumber(number float64, other float64) float64 &#123; return math.Max(number, other)&#125;- func 关键字- GetMaxNumber 函数名称- number, other 参数 类型 float64- 返回值类型 float64 分支/判断/循环 if 判断 if …else / switch 分支 for 循环","categories":[{"name":"Golang","slug":"Golang","permalink":"http://abulo.github.io/categories/Golang/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://abulo.github.io/tags/基础知识/"}]},{"title":"Golang 语言环境的搭建","slug":"Go-语言环境的搭建","date":"2019-05-05T03:20:00.000Z","updated":"2019-05-06T01:30:11.765Z","comments":true,"path":"2019/05/05/Go-语言环境的搭建/","link":"","permalink":"http://abulo.github.io/2019/05/05/Go-语言环境的搭建/","excerpt":"","text":"Golang 语言环境的搭建 下载 Python 设置环境变量 安装集成开发环境 安装第三方库 下载Go 版本选择适合操作系统的版本进行下载。 设置环境变量主要设置下面几个参数：GOROOT : 即安装Go 的目录GOPATH ：即工程目录验证配置:12345678910111213141516171819202122232425262728go envGOARCH=\"amd64\"GOBIN=\"/Users/xxx/WorkSpace/golang/bin\"GOCACHE=\"/Users/xxx/Library/Caches/go-build\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOOS=\"darwin\"GOPATH=\"/Users/xxx/WorkSpace/golang\"GOPROXY=\"\"GORACE=\"\"GOROOT=\"/usr/local/go\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\"GCCGO=\"gccgo\"CC=\"clang\"CXX=\"clang++\"CGO_ENABLED=\"1\"GOMOD=\"\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/gy/ph98vsdx00v3kxzmt_c4z79r0000gn/T/go-build551475520=/tmp/go-build -gno-record-gcc-switches -fno-common\" 12go versiongo version go1.12.4 darwin/amd64 工程结构即 GOPATH 目录下存在下面三个文件：核心是 src 目录：主要存放第三方包或者自己的源代码bin 目录：主要是编译生成的二进制文件的存放目录，假如设置了 GOBINpkg 目录： 编译、执行过程中生成的文件 12345binpkgsrc github.com yourproject 编写代码即 在GOPATH 目录下新建一个文件夹：demo-for-golang 123456789binpkgsrc github.com demo-for-golang first one_2018_01_14.go main main.go 12345678910# one_2018_01_14.gopackage firstimport ( \"fmt\")func PrintFirst()&#123; fmt.Print(\"这是第一期：环境搭建。\")&#125; 12345678910# main.gopackage mainimport ( \"demo-for-golang/first\")func main()&#123; first.PrintFirst()&#125; 执行 go run main.go 即可打印： 这是第一期: 环境搭建从上面的代码可以看出 Go 语言的代码的一般结构： 包名 导入包：不管是你自己写的文件还是第三方库 (其实就是导入文件夹里的文件) 编写函数 程序的入口是主函数：main() 包的组织和管理下载第三方库的方法是使用 Go 命令行： go get比如下载包管理的库：govendor1go get -u -v github.com/kardianos/govendor 如果你之前的 GOPATH 没有问题，那么会在GOPATH 的src 目录下多一个 http://github.com 的文件夹：下面有这样一个文件夹：..\\src\\github.com\\kardianos\\govendor 即表示下载 govendor 成功。正确使用govendor 命令需要将：GOBIN 加入环境变量中，否则会显示：bash: govendor: command not found正确使用govendor 的前提你需要先安装 git，且你的工程在 src 目录下：比如像这样的结构：12345binpkgsrc github.com demo-for-golang 进入 demo-for-golang 目录下：执行 govendor init执行 govendor add +external即会在当前目录下多出一个 vendor 目录，里面有一些自动生成的文件夹和文件。","categories":[{"name":"Golang","slug":"Golang","permalink":"http://abulo.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://abulo.github.io/tags/Golang/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://abulo.github.io/tags/环境搭建/"}]},{"title":"新年计划","slug":"新年计划","date":"2019-01-06T11:30:00.000Z","updated":"2019-01-06T11:35:58.745Z","comments":true,"path":"2019/01/06/新年计划/","link":"","permalink":"http://abulo.github.io/2019/01/06/新年计划/","excerpt":"","text":"新年计划 1.学习一门新的计算机语言,初步暂定Golang 2.看几本有意义的书 3.坚持锻炼身体 4.亲子互动多一点","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://abulo.github.io/categories/杂谈/"}],"tags":[]},{"title":"Redis.conf 中文版","slug":"Redis-conf-中文版","date":"2009-05-14T05:41:00.000Z","updated":"2019-01-06T11:16:44.463Z","comments":true,"path":"2009/05/14/Redis-conf-中文版/","link":"","permalink":"http://abulo.github.io/2009/05/14/Redis-conf-中文版/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376# Redis示例配置文件# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## 单位是大小写不敏感的，所以1GB 1Gb 1gB的写法都是完全一样的。# Redis默认是不作为守护进程来运行的。你可以把这个设置为&quot;yes&quot;让它作为守护进程来运行。# 注意，当作为守护进程的时候，Redis会把进程ID写到 /var/run/redis.piddaemonize no# 当以守护进程方式运行的时候，Redis会把进程ID默认写到 /var/run/redis.pid。你可以在这里修改路径。pidfile /var/run/redis.pid# 接受连接的特定端口，默认是6379。# 如果端口设置为0，Redis就不会监听TCP套接字。port 6379# 如果你想的话，你可以绑定单一接口；如果这里没单独设置，那么所有接口的连接都会被监听。## bind 127.0.0.1# 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果你不指定的话，Redis就不会通过unix套接字来监听。## unixsocket /tmp/redis.sock# unixsocketperm 755#一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)timeout 0# 设置服务器调试等级。# 可能值：# debug （很多信息，对开发/测试有用）# verbose （很多精简的有用信息，但是不像debug等级那么多）# notice （适量的信息，基本上是你生产环境中需要的程度）# warning （只有很重要/严重的信息会记录下来）loglevel verbose# 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。# 注意：如果Redis以守护进程方式运行，而你设置日志显示到标准输出的话，那么日志会发送到 /dev/nulllogfile stdout# 要使用系统日志记录器很简单，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。# 然后根据需要设置其他一些syslog参数就可以了。# syslog-enabled no# 指明syslog身份# syslog-ident redis# 指明syslog的设备。必须是一个用户或者是 LOCAL0 ~ LOCAL7 之一。# syslog-facility local0# 设置数据库个数。默认数据库是 DB 0，你可以通过SELECT &lt;dbid&gt; WHERE dbid（0～&apos;databases&apos; - 1）来为每个连接使用不同的数据库。databases 16################################ 快照 ################################### 把数据库存到磁盘上:## save &lt;seconds&gt; &lt;changes&gt;## 会在指定秒数和数据变化次数之后把数据库写到磁盘上。## 下面的例子将会进行把数据写入磁盘的操作:# 900秒（15分钟）之后，且至少1次变更# 300秒（5分钟）之后，且至少10次变更# 60秒之后，且至少10000次变更## 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。save 900 1save 300 10save 60 10000# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象。# 默认设置为 &quot;yes&quot;，所以几乎总是生效的。# 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key的话，那数据文件就会更大了。rdbcompression yes# 数据库的文件名dbfilename dump.rdb# 工作目录## 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。## 累加文件也放这里。## 注意你这里指定的必须是目录，不是文件名。dir ./################################# 同步 ################################### 主从同步。通过 slaveof 配置来实现Redis实例的备份。# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。## slaveof &lt;masterip&gt; &lt;masterport&gt;# 如果master设置了密码（通过下面的 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。## masterauth &lt;master-password&gt;# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：## 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。# 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步（SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。#slave-serve-stale-data yes# slave根据指定的时间间隔向服务器发送ping请求。# 时间间隔可以通过 repl_ping_slave_period 来设置。# 默认10秒。## repl-ping-slave-period 10# 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。# 默认值60秒。## 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。## repl-timeout 60################################## 安全 #################################### 要求客户端在处理任何命令时都要验证身份和密码。# 这在你信不过来访者时很有用。## 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证（例如：它们运行在自己的服务器上。）## 警告：因为Redis太快了，所以居心不良的人可以每秒尝试150k的密码来试图破解密码。# 这意味着你需要一个高强度的密码，否则破解太容易了。## requirepass foobared# 命令重命名## 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法做坏事了。## 例如:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令：## rename-command CONFIG &quot;&quot;################################### 限制 ###################################### 设置最多同时连接客户端数量。# 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。# 特殊值&quot;0&quot;表示没有限制。# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&quot;达到最大用户数上限（max number of clients reached）&quot;## maxclients 128# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。## 如果因为删除策略问题Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更多内存的错误信息给命令。# 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。## 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）的时候，这个选项还是满有用的。## 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。# 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。## 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。# （如果策略设置为&quot;noeviction&quot;的话就不无所谓了）## maxmemory &lt;bytes&gt;# 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选：## volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。# allkeys-lru -&gt; 根据LRU算法删除任何key。# volatile-random -&gt; 根据过期设置来随机删除key。# allkeys-&gt;random -&gt; 无差别随机删。# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）# noeviction -&gt; 谁也不删，直接在写操作时返回错误。## 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。## 这里涉及的命令：set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## 默认值如下：## maxmemory-policy volatile-lru# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样例做测试。# 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。## maxmemory-samples 3############################## 纯累加模式 ################################ 默认情况下，Redis是异步的把数据导出到磁盘上。这种情况下，当Redis挂掉的时候，最新的数据就丢了。# 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。# 每次启动时Redis都会把这个文件的数据读入内存里。## 注意，异步导出的数据库文件和纯累加文件可以并存（你得把上面所有&quot;save&quot;设置都注释掉，关掉导出机制）。# 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。## 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。appendonly no# 纯累加文件名字（默认：&quot;appendonly.aof&quot;）# appendfilename appendonly.aof# fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。# 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。## Redis支持三种不同的模式：## no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。# always：每次写操作都立刻写入到aof文件。慢，但是最安全。# everysec：每秒写一次。折衷方案。## 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。# 如果你真的理解了这个意味着什么，那么设置&quot;no&quot;可以获得更好的性能表现（如果丢数据的话，则只能拿到一个不是很新的快照）；# 或者相反的，你选择 &quot;always&quot; 来牺牲速度确保数据安全、完整。## 如果拿不准，就用 &quot;everysec&quot;# appendfsync alwaysappendfsync everysec# appendfsync no# 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，那么后台的存储进程（后台存储或写入AOF日志）会产生很多磁盘I/O开销。# 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。## 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。## 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）## 如果你有延迟的问题那就把这个设为 &quot;yes&quot;，否则就保持 &quot;no&quot;，这是保存持久数据的最安全的方式。no-appendfsync-on-rewrite no# 自动重写AOF文件## 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。## 工作原理：Redis记住上次重写时AOF日志的大小（或者重启后没有写操作的话，那就直接用此时的AOF文件），# 基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。## 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。## 指定百分比为0会禁用AOF自动重写特性。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################## 慢查询日志 #################################### Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。# 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间（这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景）## 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。## 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。slowlog-log-slower-than 10000# 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。（译者注：日志居然是在内存里的Orz）slowlog-max-len 128################################ 虚拟内存 ################################## 警告！虚拟内存在Redis 2.4是反对的。### 非常不鼓励使用虚拟内存！！# 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。# 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。## 要使用虚拟内存，只要把 &quot;vm-enabled&quot; 设置为 &quot;yes&quot;，并根据需要设置下面三个虚拟内存参数就可以了。vm-enabled no# vm-enabled yes# 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。## 最好的保存交换文件（被随机访问）的介质是固态硬盘（SSD）。## *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。# 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。vm-swap-file /tmp/redis.swap# &quot;vm-max-memory&quot; 配置虚拟内存可用的最大内存容量。# 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。## &quot;vm-max-memory&quot; 设置为0表示系统会用掉所有可用内存。# 这默认值不咋地，只是把你能用的内存全用掉了，留点余量会更好。# 例如，设置为剩余内存的60%-80%。vm-max-memory 0# Redis交换文件是分成多个数据页的。# 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。# 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。# 如果数据页太小，那用于存储的交换空间就会更少（假定你设置相同的数据页数量）## 如果你使用很多小对象，建议分页尺寸为64或32个字节。# 如果你使用很多大对象，那就用大一些的尺寸。# 如果不确定，那就用默认值 :)vm-page-size 32# 交换文件里数据页总数。# 根据内存中分页表（已用/未用的数据页分布情况），磁盘上每8个数据页会消耗内存里1个字节。## 交换区容量 = vm-page-size * vm-pages## 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。## 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。vm-pages 134217728# 同时可运行的虚拟内存I/O线程数。# 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。# 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。## 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。vm-max-threads 4############################### 高级配置 ################################ 当有大量数据时，适合用哈希编码（需要更多的内存），元素数量上限不能超过给定限制。# 你可以通过下面的选项来设定这些限制：hash-max-zipmap-entries 512hash-max-zipmap-value 64# 与哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。# 这种方式只有在符合下面限制的时候才可以用：list-max-ziplist-entries 512list-max-ziplist-value 64# 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。# 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。set-max-intset-entries 512# 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。# 这种编码只适合长度和元素都符合下面限制的有序序列：zset-max-ziplist-entries 128zset-max-ziplist-value 64# 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；# 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。## 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。## 建议：# 如果你对延迟比较在意的话就用 &quot;activerehashing no&quot;，每个请求延迟2毫秒不太好嘛。# 如果你不太在意延迟而希望尽快释放内存的话就设置 &quot;activerehashing yes&quot;。activerehashing yes################################## 包含 #################################### 包含一个或多个其他配置文件。# 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。# 包含文件特性允许你引人其他配置文件，所以好好利用吧。## include /path/to/local.conf# include /path/to/other.conf","categories":[{"name":"Redis","slug":"Redis","permalink":"http://abulo.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://abulo.github.io/tags/Redis/"}]},{"title":"Python DBUtils数据连接池与MySQL配合用法","slug":"Python-DBUtils数据连接池与MySQL配合用法","date":"2009-05-06T08:53:00.000Z","updated":"2019-01-06T09:03:59.729Z","comments":true,"path":"2009/05/06/Python-DBUtils数据连接池与MySQL配合用法/","link":"","permalink":"http://abulo.github.io/2009/05/06/Python-DBUtils数据连接池与MySQL配合用法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178# -*- coding: UTF-8 -*-&quot;&quot;&quot;desc:数据库操作类@note:1、执行带参数的ＳＱＬ时，请先用sql语句指定需要输入的条件列表，然后再用tuple/list进行条件批配２、在格式ＳＱＬ中不需要使用引号指定数据类型，系统会根据输入参数自动识别３、在输入的值中不需要使用转意函数，系统会自动处理&quot;&quot;&quot;import MySQLdbfrom MySQLdb.cursors import DictCursorfrom DBUtils.PooledDB import PooledDBimport Config&quot;&quot;&quot;Config是一些数据库的配置文件&quot;&quot;&quot;class Mysql(object): &quot;&quot;&quot; MYSQL数据库对象，负责产生数据库连接 , 此类中的连接采用连接池实现 获取连接对象：conn = Mysql.getConn() 释放连接对象;conn.close()或del conn &quot;&quot;&quot; #连接池对象 __pool = None def __init__(self): &quot;&quot;&quot; 数据库构造函数，从连接池中取出连接，并生成操作游标 &quot;&quot;&quot;# self._conn = MySQLdb.connect(host=Config.DBHOST , port=Config.DBPORT , user=Config.DBUSER , passwd=Config.DBPWD ,# db=Config.DBNAME,use_unicode=False,charset=Config.DBCHAR,cursorclass=DictCursor) self._conn = Mysql.__getConn() self._cursor = self._conn.cursor() @staticmethod def __getConn(): &quot;&quot;&quot; @summary: 静态方法，从连接池中取出连接 @return MySQLdb.connection &quot;&quot;&quot; if Mysql.__pool is None: __pool = PooledDB(creator=MySQLdb, mincached=1 , maxcached=20 , host=Config.DBHOST , port=Config.DBPORT , user=Config.DBUSER , passwd=Config.DBPWD , db=Config.DBNAME,use_unicode=False,charset=Config.DBCHAR,cursorclass=DictCursor) return __pool.connection() def getAll(self,sql,param=None): &quot;&quot;&quot; @summary: 执行查询，并取出所有结果集 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 &quot;&quot;&quot; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) if count&gt;0: result = self._cursor.fetchall() else: result = False return result def getOne(self,sql,param=None): &quot;&quot;&quot; @summary: 执行查询，并取出第一条 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 &quot;&quot;&quot; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) if count&gt;0: result = self._cursor.fetchone() else: result = False return result def getMany(self,sql,num,param=None): &quot;&quot;&quot; @summary: 执行查询，并取出num条结果 @param sql:查询ＳＱＬ，如果有查询条件，请只指定条件列表，并将条件值使用参数[param]传递进来 @param num:取得的结果条数 @param param: 可选参数，条件列表值（元组/列表） @return: result list/boolean 查询到的结果集 &quot;&quot;&quot; if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) if count&gt;0: result = self._cursor.fetchmany(num) else: result = False return result def insertOne(self,sql,value): &quot;&quot;&quot; @summary: 向数据表插入一条记录 @param sql:要插入的ＳＱＬ格式 @param value:要插入的记录数据tuple/list @return: insertId 受影响的行数 &quot;&quot;&quot; self._cursor.execute(sql,value) return self.__getInsertId() def insertMany(self,sql,values): &quot;&quot;&quot; @summary: 向数据表插入多条记录 @param sql:要插入的ＳＱＬ格式 @param values:要插入的记录数据tuple(tuple)/list[list] @return: count 受影响的行数 &quot;&quot;&quot; count = self._cursor.executemany(sql,values) return count def __getInsertId(self): &quot;&quot;&quot; 获取当前连接最后一次插入操作生成的id,如果没有则为０ &quot;&quot;&quot; self._cursor.execute(&quot;SELECT @@IDENTITY AS id&quot;) result = self._cursor.fetchall() return result[0][&apos;id&apos;] def __query(self,sql,param=None): if param is None: count = self._cursor.execute(sql) else: count = self._cursor.execute(sql,param) return count def update(self,sql,param=None): &quot;&quot;&quot; @summary: 更新数据表记录 @param sql: ＳＱＬ格式及条件，使用(%s,%s) @param param: 要更新的 值 tuple/list @return: count 受影响的行数 &quot;&quot;&quot; return self.__query(sql,param) def delete(self,sql,param=None): &quot;&quot;&quot; @summary: 删除数据表记录 @param sql: ＳＱＬ格式及条件，使用(%s,%s) @param param: 要删除的条件 值 tuple/list @return: count 受影响的行数 &quot;&quot;&quot; return self.__query(sql,param) def begin(self): &quot;&quot;&quot; @summary: 开启事务 &quot;&quot;&quot; self._conn.autocommit(0) def end(self,option=&apos;commit&apos;): &quot;&quot;&quot; @summary: 结束事务 &quot;&quot;&quot; if option==&apos;commit&apos;: self._conn.commit() else: self._conn.rollback() def dispose(self,isEnd=1): &quot;&quot;&quot; @summary: 释放连接池资源 &quot;&quot;&quot; if isEnd==1: self.end(&apos;commit&apos;) else: self.end(&apos;rollback&apos;); self._cursor.close() self._conn.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://abulo.github.io/categories/Python/"},{"name":"MySQL","slug":"Python/MySQL","permalink":"http://abulo.github.io/categories/Python/MySQL/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://abulo.github.io/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://abulo.github.io/tags/MySQL/"},{"name":"DBUtils","slug":"DBUtils","permalink":"http://abulo.github.io/tags/DBUtils/"}]},{"title":"昨天的影院才是天堂影院","slug":"昨天的影院才是天堂影院","date":"2009-03-20T01:45:00.000Z","updated":"2019-01-06T08:33:44.898Z","comments":true,"path":"2009/03/20/昨天的影院才是天堂影院/","link":"","permalink":"http://abulo.github.io/2009/03/20/昨天的影院才是天堂影院/","excerpt":"","text":"这是一场关于梦想的电影往事。 二战时期的意大利西西里岛，既流传着一段美丽传说，也孕育着这么一个孩子的梦想：关于理想，关于友情，关于爱情，关于亲情。 电影梦 这个梦想是多多的，也是阿尔夫莱多的，更是朱塞佩·托纳托雷的。我不敢妄称多多就是朱塞佩·托纳托雷童年的幻像，但我知道朱塞佩·托纳托雷肯定也曾做过多多类似的梦——关于电影的梦。同样，那也曾是阿尔夫莱多的梦。阿尔夫莱多知道自己再没有圆梦的机会了，他要多多去圆梦，也是去圆他自己的梦。他不希望多多圆梦的途中会被打扰，会半途而废，甚至不惜于破坏多多与艾列娜的爱情来表示对梦想的虔诚，为多多画出这样一个美丽的梦境，将多多送了出去。他知道人在梦里是不能被打扰的，于是他在车站送行的时候狠狠的抓住多多：不准回来！不准想我们！不准回头！不准写信！不准妥协！忘了我们！ 友情梦 多多与阿尔夫莱多忘年的情谊，起源与古怪精灵的多多从阿尔夫莱多的放映室偷胶片开始。封建的神父作为影院的所有者，审片的态度一点也不马虎。胶片剪了又剪，多多的私藏也随着废弃胶片的增多而日益丰富，直至一天因胶片引发的意外火灾险些要了多多妹妹的命，阿尔夫莱多才意识到——这个小鬼原来有着和自己一样的梦，他要培养多多。但是阿尔夫莱多毕竟是成人，他知道多多不可能一辈子都做一名电影放映员，他告诉多多：“生活不是电影，生活比电影苦多了！”特别是在多多救了阿尔夫莱多的命之后，阿尔夫莱多更是将满心的希望都寄托在了多多的身上，他不仅像朋友，更像是父亲般的关爱着多多。最后当多多独自坐在影院欣赏阿尔夫莱多留给自己的遗物时，银幕上还能找到失落的东西，以作回忆的凭据，不免徒生无可奈何花落去的怅惘。 爱情梦 和大多数青春期男孩一样，多多邂逅了美丽的艾列娜，唠下了朝思夜想的心病。随后，寻着阿尔夫莱多故事中士兵足迹的多多，终于用毅力换来了艾列娜的爱情。可是在那样复杂的年代，怎么可能静的下心来谈爱情？何况多多还背负着阿尔夫莱多的电影梦。三十年后多多重归故里，慕然回首，看见梦中人伫立街头，斑斑银发随风飘舞，怎一个感伤了得。当天晚上，这对有情人终于圆了自己三十年前的梦。第二天多多要离开了，挂电话给艾列娜，刚要设想幸福的将来，却被艾列娜打住： “不，没有将来了，只有过去，昨晚只是一场梦而已，一个美好的梦。是我们小时候没实现的梦。。。我想，没有比这样更好的结局了。” 亲情梦 影片的开始就是多多的母亲在给多多挂电话。三十年了，三十年多多都没有回来，没有回来一次看望自己的母亲和妹妹。这次阿尔夫莱多去世，多多应该回来了。餐桌上，多多为自己三十年来对家庭的不闻不问进行忏悔，母亲宽容的摇摇头：“我从未要求，你也无需解释。”接着母亲给多多讲了他小时侯关于门锁的故事，多多沉默不语。三十年了，妹妹对他觉得陌生了，而母亲的爱，却始终没有改变。多多知道，母亲在梦了都盼望着他会在某一天的晚上突然回来。 梦终会醒，可是电影要继续，生活也要继续。 电影就是将平淡无奇的镜头都剪去以后的人生。","categories":[{"name":"影评","slug":"影评","permalink":"http://abulo.github.io/categories/影评/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://abulo.github.io/tags/电影/"}]},{"title":"英雄和英雄","slug":"英雄和英雄","date":"2008-11-14T16:44:00.000Z","updated":"2019-01-06T08:34:37.262Z","comments":true,"path":"2008/11/15/英雄和英雄/","link":"","permalink":"http://abulo.github.io/2008/11/15/英雄和英雄/","excerpt":"","text":"阿喀琉斯，以前总会唾弃之，他的出色才能，使得野蛮的斯巴达士兵们躲在木马中潜入特洛伊，然后上演对于一个无比文明的国家毁灭性的屠城！他不受暴君的约束，有自己的辨识能力，也有自己独立的个性，当然，更加拥有的，是当时时代下生存和被崇拜的力量——武力，他的格斗术和如此的个性，决定了他只能成为一个英雄，而不是一个君主。 ­ 故事很老土，就是因为特洛伊的二王子，也就是悲剧英雄赫克托耳的弟弟，勾引了希腊第一美女“水性杨花”的海伦，引发了希腊和特洛伊的一场战争。阿喀琉斯，为了自己成为历史上不朽的英雄而被希腊君主利用而战；赫克托耳，为了保护自己那个懦弱不敢承担责任（或者说没有能力承担责任）的弟弟，以及为了保护自己所热爱的子民们而战斗！ ­ 英雄和英雄相遇之际就擦出了火花，他们甚至开始不伤害彼此（虽然也有一些政治因素在此）。而赫克托耳的美丽的表妹被希腊人俘虏后，与阿喀琉斯迸出了爱情的火花，短短的几天内，差点改变一个英雄的铸就，她像刀鞘一样，差点就保护了国家的一切！可是被政治利用了的战争中，永远都是那么不尽人意，赫克托耳错杀了阿喀琉斯的堂弟。命运弄人，最终这个身来就神赐予力量的阿喀琉斯，重上战场，赫克托耳——一个国家的精神支柱就败死在阿喀琉斯的手下！特洛伊就此而没有了胜算。而在之后的木马屠城中，这个可怜的英雄，又死于红颜祸水。虽然有复仇的快感，却也因为阿喀琉斯的死亡而抱憾而叹…… ­ 这就是英雄与英雄！ ­","categories":[{"name":"影评","slug":"影评","permalink":"http://abulo.github.io/categories/影评/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://abulo.github.io/tags/电影/"}]},{"title":"The Legend of 1900","slug":"The-Legend-of-1900","date":"2008-10-21T13:59:00.000Z","updated":"2019-01-06T08:34:49.620Z","comments":true,"path":"2008/10/21/The-Legend-of-1900/","link":"","permalink":"http://abulo.github.io/2008/10/21/The-Legend-of-1900/","excerpt":"","text":"生命像极了一场茫无头绪的冒险，所以我们往往会敬佩那些流连于同一个地方，专注于同一件事情的人。被无常的命运折磨的时候，拒绝改变有时候能提供给人一种安全感。所以《海上钢琴师》从一开始便给了我们很多期待。一个被遗弃在巨型渡轮上的孤儿突然间成了天才的钢琴师，他一辈子都不曾下过这艘船。海、船、来来往往的两千名乘客和他的钢琴构成了他唯一的世界。 ­ 1900的音乐是和他心底始终保有的那些价值分不开的，他弹琴很大程度上是为了不离开他内心那个与世隔绝的世界。但没有印证我们内心的期待，我们不知道这个男人在想什么？他是个英雄还是个疯子？最后那段小号演奏仿佛是在追忆些什么。是的，也许的确是在追忆些什么，但，凭什么追忆呢？ 人是惧怕新环境的，就像我们总喜欢蹲在自己被窝里添伤口一样，我们不只是不想让别人看到自己伤心，还因为我们怀念被子熟悉的味道。。一旦空质量变了，我们的心也就飘荡不定了。。是没有勇气还是我们习惯安逸？是没有本钱还是害怕失败？没有答案，一切都在发生，一切都流逝，生就是死的一部分罢了。。。就像双腿蹲在马桶上一样这么的不可思议又切实存在！ ­ “Max,我在想我用两只手弹出的音乐，我只希望天堂里也有钢琴！”­","categories":[{"name":"影评","slug":"影评","permalink":"http://abulo.github.io/categories/影评/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://abulo.github.io/tags/电影/"}]},{"title":"这就是我","slug":"这就是我","date":"2008-03-28T07:27:00.000Z","updated":"2019-01-06T07:29:27.674Z","comments":true,"path":"2008/03/28/这就是我/","link":"","permalink":"http://abulo.github.io/2008/03/28/这就是我/","excerpt":"","text":"顽石无材补苍天 ­ 沦落凡尘二十年 ­ 修成正果还夙愿 ­ 可否邂逅女娲仙 ­ 青城峰下，顽石无材，奈何补苍天？ ­ 余，本一顽石，出自寒门，历二十载，沐山川之灵秀，秉日月之精华，终修成正果，甲申年秋，忝列金榜，得以游学于蓉城。学业既成，足迹遍及川而不得遂其愿也。为衣食计，丁亥年夏，仍郁郁不得志。 ­ 本人爱好甚广 ­ 【$，￥，篮球，足球，台球】 ­ 其余【电脑游戏，饶舌，贫，喝酒，…………】 ­ 本人梦境【愿望理想】混之而言出：“世上出于乌托邦，愿生活于那圣地，步入天堂，漫过神圣走廊，天使笑容让我感到无比慈祥，内心深感舒畅，此地人皆平等，无暴力，纠纷与偏见，至今仍留恋此梦”不安于现状。偶个性隐于开朗之说又隐于内向之说，全仗射手星之罩，宙斯为之袒护，天神四方，不惧万物，乃“天才”自称。口语常念“静享天赐安眠”，自知知足长乐。 ­ 文章本天成，妙手偶得。奉上，不揣固陋，诚惶诚恐。­","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://abulo.github.io/categories/杂谈/"}],"tags":[]}]}